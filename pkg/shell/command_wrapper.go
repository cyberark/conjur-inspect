package shell

import (
	"bytes"
	"io"
	"os/exec"
	"strings"

	"github.com/cyberark/conjur-inspect/pkg/log"
)

// CommandWrapper represents a wrapper around an executable command
type CommandWrapper struct {
	name string
	args []string
}

// NewCommandWrapper creates a new CommandWrapper with the provided name and args.
// It returns a pointer to the created CommandWrapper.
func NewCommandWrapper(name string, args ...string) *CommandWrapper {
	return &CommandWrapper{
		name: name,
		args: args,
	}
}

// Run executes the command and returns its output as readers for stdout and
// stderr, along with any error that occurred.
// It returns three values, which are based on the results of the command execution:
// stdout io.Reader: The standard output generated by the command.
// stderr io.Reader: The standard error generated by the command.
// err error: An error, if one occurred while executing the command.
func (wrapper *CommandWrapper) Run() (stdout, stderr io.Reader, err error) {
	outBuffer := new(bytes.Buffer)
	errBuffer := new(bytes.Buffer)

	cmdPath, err := exec.LookPath(wrapper.name)
	if err != nil {
		return outBuffer, errBuffer, err
	}

	log.Debug(
		"Executing command: %s",
		strings.Join(append([]string{cmdPath}, wrapper.args...), " "),
	)

	exec := exec.Command(cmdPath, wrapper.args...)

	exec.Stdout = outBuffer
	exec.Stderr = errBuffer

	err = exec.Run() // and wait

	return outBuffer, errBuffer, err
}

// RunCombinedOutput executes the command and returns its combined standard
// output and error streams as a single reader, along with any error that occurred.
// It returns two values, which are based on the results of the command execution:
// output []byte: The standard output and error generated by the command.
// err error: An error, if one occurred while executing the command.
func (wrapper *CommandWrapper) RunCombinedOutput() (io.Reader, error) {
	outBuffer := new(bytes.Buffer)

	cmdPath, err := exec.LookPath(wrapper.name)
	if err != nil {
		return outBuffer, err
	}

	log.Debug(
		"Executing command: %s",
		strings.Join(append([]string{cmdPath}, wrapper.args...), " "),
	)

	exec := exec.Command(cmdPath, wrapper.args...)

	exec.Stdout = outBuffer
	exec.Stderr = outBuffer

	err = exec.Run() // and wait

	return outBuffer, err
}
